{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Verdana-Bold;\f1\fnil\fcharset0 Verdana;\f2\fnil\fcharset0 Verdana-Italic;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red108\green5\blue211;\red0\green0\blue255;
\red77\green78\blue78;\red64\green128\blue0;\red255\green0\blue0;\red0\green22\blue176;}
{\*\expandedcolortbl;;\csgenericrgb\c0\c0\c0;\csgenericrgb\c42300\c1800\c82800;\csgenericrgb\c0\c0\c100000;
\csgenericrgb\c30000\c30500\c30500;\csgenericrgb\c25000\c50000\c0;\csgenericrgb\c100000\c0\c0;\csgenericrgb\c0\c8700\c69000;}
\deftab480
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b\fs24 \cf2 use
\f1\b0  \cf3 AppleScript\cf2  \cf4 version\cf2  "2.5" \cf5 -- requires OS X 10.11 or higher\cf2 \
\pard\pardeftab480\slleading40\pardirnatural\partightenfactor0

\f0\b \cf2 use
\f1\b0  
\f2\i \cf4 scripting additions
\f1\i0 \cf2 \

\f0\b use
\f1\b0  
\f2\i \cf4 framework
\f1\i0 \cf2  "Foundation"\

\f0\b use
\f1\b0  
\f2\i \cf4 framework
\f1\i0 \cf2  "EventKit"\
\
\cf5 -- You need to fetch the event store first; it's required for many other handlers. This also triggers authentication if needed.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 fetch store
\f1\b0 \cf2 \
	\cf5 -- create event store and get the OK to access Calendars\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEKEventStore\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKEventStore's\cf2  \cf7 alloc\cf2 ()'s \cf7 init\cf2 ()\
	\cf6 theEKEventStore's\cf2  \cf7 requestAccessToEntityType\cf2 :0 \cf7 completion\cf2 :(
\f2\i \cf4 missing value
\f1\i0 \cf2 )\
	\cf5 -- check if app has access; this will still occur the first time you OK authorization\cf2 \
	
\f0\b set
\f1\b0  \cf6 authorizationStatus\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKEventStore's\cf2  \cf7 authorizationStatusForEntityType\cf2 :0\
	
\f0\b if
\f1\b0  \cf6 authorizationStatus\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  3 
\f0\b then
\f1\b0 \
		
\f0\b \cf8 display dialog
\f1\b0 \cf2  "Access must be given in System Preferences" & \cf3 linefeed\cf2  & "-> Security & Privacy first." \cf8 buttons\cf2  \{"OK"\} \cf8 default button\cf2  1\
		
\f0\b tell
\f1\b0  
\f2\i \cf4 application
\f1\i0 \cf2  "System Preferences"\
			
\f0\b \cf4 activate
\f1\b0 \cf2 \
			
\f0\b tell
\f1\b0  
\f2\i \cf4 pane
\f1\i0 \cf2  
\f2\i \cf3 id
\f1\i0 \cf2  "com.apple.preference.security" 
\f0\b to
\f1\b0  
\f0\b \cf4 reveal
\f1\b0 \cf2  
\f2\i \cf4 anchor
\f1\i0 \cf2  "Privacy"\
		
\f0\b end
\f1\b0  
\f0\b tell
\f1\b0 \
		
\f0\b error
\f1\b0  \cf4 number\cf2  -128\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theEKEventStore\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 fetch store
\f1\b0 \cf2 \
\
\cf5 -- You often need a reference to the relevant calendar; get it here.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 fetch calendar
\f1\b0 \cf2  \cf6 calName\cf2  \cf4 cal type\cf2  \cf6 calType\cf2  \cf4 event store\cf2  \cf6 theStore\cf2 \
	
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal local
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  0\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal cloud
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  1\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal exchange
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  2\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal subscription
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  3\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal birthday
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  4\
	
\f0\b else
\f1\b0 \
		
\f0\b error
\f1\b0  "Invalid cal type"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	\cf5 -- get calendars that can store events\cf2 \
	
\f0\b set
\f1\b0  \cf6 theCalendars\cf2  
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 calendarsForEntityType\cf2 :0\
	\cf5 -- get the requested calendar\cf2 \
	
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title == %@ AND type IN %@", \cf6 calName\cf2 , \{\cf6 calType\cf2 \})\
	
\f0\b return
\f1\b0  (\cf6 theCalendars's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 theNSPredicate\cf2 )'s \cf7 firstObject\cf2 ()\

\f0\b end
\f1\b0  
\f0\b \cf4 fetch calendar
\f1\b0 \cf2 \
\

\f0\b on
\f1\b0  
\f0\b \cf4 fetch calendars
\f1\b0 \cf2  \cf6 listOfCalNames\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2  \cf4 cal type list\cf2  \cf6 listOfCalTypes\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2  : \{\} \cf4 event store\cf2  \cf6 theStore\cf2 \
	\cf5 -- get calendars that can store events\cf2 \
	
\f0\b set
\f1\b0  \cf6 theCalendars\cf2  
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 calendarsForEntityType\cf2 :0\
	
\f0\b if
\f1\b0  \cf6 listOfCalTypes\cf2  = \{\} 
\f0\b then
\f1\b0 \
		
\f0\b if
\f1\b0  \cf6 listOfCalNames\cf2  = \{\} 
\f0\b then
\f1\b0 \
			
\f0\b return
\f1\b0  \cf6 theCalendars\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \
		
\f0\b else
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title IN %@", \cf6 listOfCalNames\cf2 )\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b else
\f1\b0 \
		
\f0\b repeat
\f1\b0  
\f0\b with
\f1\b0  \cf6 i\cf2  
\f0\b from
\f1\b0  1 
\f0\b to
\f1\b0  
\f0\b \cf4 count
\f1\b0 \cf2  
\f0\b of
\f1\b0  \cf6 listOfCalTypes\cf2 \
			
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  
\f2\i \cf4 item
\f1\i0 \cf2  \cf6 i\cf2  
\f0\b of
\f1\b0  \cf6 listOfCalTypes\cf2 \
			
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal local
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  0\
			
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal cloud
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  1\
			
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal exchange
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  2\
			
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal subscription
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  3\
			
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 calType\cf2  = 
\f2\i \cf3 cal birthday
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 calType\cf2  
\f0\b to
\f1\b0  4\
			
\f0\b else
\f1\b0 \
				
\f0\b error
\f1\b0  "Invalid cal type"\
			
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
			
\f0\b set
\f1\b0  
\f2\i \cf4 item
\f1\i0 \cf2  \cf6 i\cf2  
\f0\b of
\f1\b0  \cf6 listOfCalTypes\cf2  
\f0\b to
\f1\b0  \cf6 calType\cf2 \
		
\f0\b end
\f1\b0  
\f0\b repeat
\f1\b0 \
		
\f0\b if
\f1\b0  \cf6 listOfCalNames\cf2  = \{\} 
\f0\b then
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("type IN %@", \cf6 listOfCalTypes\cf2 )\
		
\f0\b else
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title IN %@ AND type IN %@", \cf6 listOfCalNames\cf2 , \cf6 listOfCalTypes\cf2 )\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  (\cf6 theCalendars's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 theNSPredicate\cf2 ) 
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 fetch calendars
\f1\b0 \cf2 \
\
\
\cf5 -- In theory, more than one event can have the same external ID, so this returns a list of events.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 fetch events by UID
\f1\b0 \cf2  \cf6 calID\cf2  \cf4 event store\cf2  \cf6 theStore\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theStore's\cf2  \cf7 calendarItemsWithExternalIdentifier\cf2 :\cf6 calID\cf2 )\
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEvents's\cf2  \cf7 sortedArrayUsingSelector\cf2 :"compareStartDateWithEvent:"\
	
\f0\b return
\f1\b0  \cf6 theEvents\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 fetch events by UID
\f1\b0 \cf2 \
\
\cf5 -- The main way to search for events. Dates can be AS dates or NSDates.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 fetch events
\f1\b0 \cf2  \cf4 starting date\cf2  \cf6 startDate\cf2  \cf4 ending date\cf2  \cf6 endDate\cf2  \cf4 searching cals\cf2  \cf6 calList\cf2  \cf4 event store\cf2  \cf6 theStore\cf2 \
	\cf5 -- check it it is a list/array of calendars, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.\cf2 \
	
\f0\b set
\f1\b0  \cf6 calListArray\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray's\cf2  \cf7 arrayWithObject\cf2 :\cf6 calList\cf2 \
	
\f0\b set
\f1\b0  \cf6 calList\cf2  
\f0\b to
\f1\b0  \cf6 calListArray's\cf2  \cf7 |firstObject|\cf2 ()\
	
\f0\b if
\f1\b0  
\f0\b not
\f1\b0  (\cf6 calList's\cf2  \cf7 isKindOfClass\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray\cf2 )) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0  
\f0\b set
\f1\b0  \cf6 calList\cf2  
\f0\b to
\f1\b0  \cf6 calListArray\cf2 \
	
\f0\b set
\f1\b0  \cf6 thePredicate\cf2  
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 predicateForEventsWithStartDate\cf2 :\cf6 startDate\cf2  \cf7 endDate\cf2 :\cf6 endDate\cf2  \cf7 calendars\cf2 :\cf6 calList\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 eventsMatchingPredicate\cf2 :\cf6 thePredicate\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEvents's\cf2  \cf7 sortedArrayUsingSelector\cf2 :"compareStartDateWithEvent:"\
	
\f0\b return
\f1\b0  \cf6 theEvents\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 fetch events
\f1\b0 \cf2 \
\
\cf5 -- If you have retrieved events, you can use this to refine the resulting list. Summary, location, and description are case-insensitive strings; the other parameters are booleans. Pass missing value for parameters you're not interested in.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 filter events
\f1\b0 \cf2  \cf4 event list\cf2  \cf6 theEvents\cf2  \cf4 event summary\cf2  \cf6 theTitle\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event location\cf2  \cf6 theLocation\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event description\cf2  \cf6 desc\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 has attendees\cf2  \cf6 hasA\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 has recurrence\cf2  \cf6 hasRecRules\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 runs all day\cf2  \cf6 allDay\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2 \
	\cf5 -- check it it is a list/array of events, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEventsArray\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray's\cf2  \cf7 arrayWithObject\cf2 :\cf6 theEvents\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEventsArray's\cf2  \cf7 |firstObject|\cf2 ()\
	
\f0\b if
\f1\b0  
\f0\b not
\f1\b0  (\cf6 theEvents's\cf2  \cf7 isKindOfClass\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray\cf2 )) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0  
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEventsArray\cf2 \
	
\f0\b set
\f1\b0  \cf6 predArray\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSMutableArray's\cf2  \cf7 arrayWithCapacity\cf2 :6\
	
\f0\b if
\f1\b0  \cf6 theTitle\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title ==[c] %@", \cf6 theTitle\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 theLocation\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("location ==[c] %@", \cf6 theLocation\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 desc\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("hasNotes == %@ AND notes ==[c] %@", 
\f2\i \cf3 true
\f1\i0 \cf2 , \cf6 desc\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 hasA\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("hasAttendees == %@", \cf6 hasA\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 hasRecRules\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("hasRecurrenceRules == %@", \cf6 hasRecRules\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 allDay\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 predArray's\cf2  \cf7 addObject\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("allDay == %@", \cf6 allDay\cf2 ))\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b set
\f1\b0  \cf6 theCount\cf2  
\f0\b to
\f1\b0  
\f0\b \cf4 count
\f1\b0 \cf2  
\f0\b of
\f1\b0  \cf6 predArray\cf2 \
	\cf5 -- do nothing if count is 0; if 1, just use the first predicate in the array; otherwise and them all\cf2 \
	
\f0\b if
\f1\b0  \cf6 theCount\cf2  = 1 
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theEvents's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :(\cf6 predArray's\cf2  \cf7 firstObject\cf2 ()))\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 theCount\cf2  > 1 
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 thePred\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSCompoundPredicate's\cf2  \cf7 andPredicateWithSubpredicates\cf2 :\cf6 predArray\cf2 \
		
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theEvents's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 thePred\cf2 )\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theEvents\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 filter events
\f1\b0 \cf2 \
\
\cf5 -- When you have retrieved events, you can use this to refine the resulting list. If useRegex is true, the string(s) you pass will be treated as regular expression patterns, and matches will be sought. If useRegex is false, you can use ? as a wildcard for single characters and * as a wildcard for zero or more characters. Pass missing value for parameters you're not interested in.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 filter events by pattern
\f1\b0 \cf2  \cf4 event list\cf2  \cf6 theEvents\cf2  \cf4 event summary\cf2  \cf6 theTitle\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event description\cf2  \cf6 desc\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event location\cf2  \cf6 theLocation\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 using regex\cf2  \cf6 regexFlag\cf2  : 
\f2\i \cf3 true
\f1\i0 \cf2 \
	\cf5 -- check it it is a list/array of events, and if not make it one. We do this by making a new array and checking the class of its first object. This copes with arrays and lists.\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEventsArray\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray's\cf2  \cf7 arrayWithObject\cf2 :\cf6 theEvents\cf2 \
	
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEventsArray's\cf2  \cf7 |firstObject|\cf2 ()\
	
\f0\b if
\f1\b0  
\f0\b not
\f1\b0  (\cf6 theEvents's\cf2  \cf7 isKindOfClass\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray\cf2 )) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0  
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  \cf6 theEventsArray\cf2 \
	
\f0\b if
\f1\b0  \cf6 theTitle\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b if
\f1\b0  \cf6 regexFlag\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title MATCHES %@", \cf6 theTitle\cf2 )\
		
\f0\b else
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("title LIKE %@", \cf6 theTitle\cf2 )\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theEvents's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 theNSPredicate\cf2 )\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 desc\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b if
\f1\b0  \cf6 regexFlag\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("hasNotes == %@ AND notes MATCHES %@", 
\f2\i \cf3 true
\f1\i0 \cf2 , \cf6 desc\cf2 )\
		
\f0\b else
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("hasNotes == %@ AND notes LIKE %@", 
\f2\i \cf3 true
\f1\i0 \cf2 , \cf6 desc\cf2 )\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theEvents's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 theNSPredicate\cf2 )\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 theLocation\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b if
\f1\b0  \cf6 useRegex\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("location MATCHES %@", \cf6 theLocation\cf2 )\
		
\f0\b else
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 theNSPredicate\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSPredicate's\cf2  \cf7 predicateWithFormat_\cf2 ("location LIKE %@", \cf6 theLocation\cf2 )\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theEvents\cf2  
\f0\b to
\f1\b0  (\cf6 theEvents's\cf2  \cf7 filteredArrayUsingPredicate\cf2 :\cf6 theNSPredicate\cf2 )\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theEvents\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 filter events by pattern
\f1\b0 \cf2 \
\
\cf5 -- Deletes an event. For recurring events, futureFlag should be true to delete future recurrences.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 remove event
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2  \cf4 event store\cf2  \cf6 theStore\cf2  \cf4 future events\cf2  \cf6 futureFlag\cf2  : 
\f2\i \cf3 true
\f1\i0 \cf2 \
	
\f0\b set
\f1\b0  \{\cf6 theResult\cf2 , \cf6 theError\cf2 \} 
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 removeEvent\cf2 :\cf6 theEvent\cf2  \cf7 span\cf2 :\cf6 futureFlag\cf2  \cf7 commit\cf2 :
\f2\i \cf3 true
\f1\i0 \cf2  \cf7 |error|\cf2 :(
\f2\i \cf4 reference
\f1\i0 \cf2 )\
	
\f0\b if
\f1\b0  
\f0\b not
\f1\b0  \cf6 theResult\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0  
\f0\b error
\f1\b0  (\cf6 theError's\cf2  \cf7 localizedDescription\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 text
\f1\i0 \cf2 )\

\f0\b end
\f1\b0  
\f0\b \cf4 remove event
\f1\b0 \cf2 \
\
\cf5 -- Creates a new event. Location and notes can be missing value, start and end dates can be AS dates or NSDates, and allDay is a boolean. You still need to save it using the saveEvent::: handler below.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 create event
\f1\b0 \cf2  \cf4 event store\cf2  \cf6 theStore\cf2  \cf4 destination calendar\cf2  \cf6 theCal\cf2  \cf4 event summary\cf2  \cf6 theTitle\cf2  \cf4 starting date\cf2  \cf6 startD\cf2  \cf4 ending date\cf2  \cf6 endD\cf2  \cf4 runs all day\cf2  \cf6 allDay\cf2  : 
\f2\i \cf3 false
\f1\i0 \cf2  \cf4 event location\cf2  \cf6 theLocation\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event description\cf2  \cf6 desc\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2 \
	
\f0\b set
\f1\b0  \cf6 newEvent\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKEvent's\cf2  \cf7 eventWithEventStore\cf2 :\cf6 theStore\cf2 \
	\cf6 newEvent's\cf2  \cf7 setCalendar\cf2 :\cf6 theCal\cf2 \
	\cf6 newEvent's\cf2  \cf7 setTitle\cf2 :\cf6 theTitle\cf2 \
	\cf6 newEvent's\cf2  \cf7 setStartDate\cf2 :\cf6 startD\cf2 \
	\cf6 newEvent's\cf2  \cf7 setEndDate\cf2 :\cf6 endD\cf2 \
	\cf6 newEvent's\cf2  \cf7 setAllDay\cf2 :\cf6 allDay\cf2 \
	
\f0\b if
\f1\b0  \cf6 theLocation\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 newEvent's\cf2  \cf7 setLocation\cf2 :\cf6 theLocation\cf2 \
	
\f0\b if
\f1\b0  \cf6 desc\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 newEvent's\cf2  \cf7 setNotes\cf2 :\cf6 desc\cf2 \
	
\f0\b return
\f1\b0  \cf6 newEvent\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 create event
\f1\b0 \cf2 \
\
\cf5 -- Supply missing value for properties you do not want to change.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 modify event
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2  \cf4 destination calendar\cf2  \cf6 theCal\cf2  \cf4 event summary\cf2  \cf6 theTitle\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 starting date\cf2  \cf6 startD\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 ending date\cf2  \cf6 endD\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 runs all day\cf2  \cf6 allDay\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event location\cf2  \cf6 theLocation\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 event description\cf2  \cf6 desc\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2 \
	
\f0\b if
\f1\b0  \cf6 theCal\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setCalendar\cf2 :\cf6 theCal\cf2 \
	
\f0\b if
\f1\b0  \cf6 theTitle\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setTitle\cf2 :\cf6 theTitle\cf2 \
	
\f0\b if
\f1\b0  \cf6 startD\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setStartDate\cf2 :\cf6 startD\cf2 \
	
\f0\b if
\f1\b0  \cf6 endD\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setEndDate\cf2 :\cf6 endD\cf2 \
	
\f0\b if
\f1\b0  \cf6 allDay\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setAllDay\cf2 :\cf6 allDay\cf2 \
	
\f0\b if
\f1\b0  \cf6 theLocation\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setLocation\cf2 :\cf6 theLocation\cf2 \
	
\f0\b if
\f1\b0  \cf6 desc\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 setNotes\cf2 :\cf6 desc\cf2 \
	
\f0\b return
\f1\b0  \cf6 theEvent\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 modify event
\f1\b0 \cf2 \
\
\cf5 -- The time zone can be missing value (for floating times), a valid time zone name, or a Cocoa NSTimeZone.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 modify zone
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2  \cf4 time zone\cf2  \cf6 tz\cf2 \
	
\f0\b if
\f1\b0  \cf6 tz\cf2  
\f0\b is
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 theEvent's\cf2  \cf7 setTimeZone\cf2 :\cf6 tz\cf2 \
	
\f0\b else
\f1\b0 \
		\cf5 -- workaround to make sure tz is a Cocoa object so we can test its class\cf2 \
		
\f0\b set
\f1\b0  \cf6 tz\cf2  
\f0\b to
\f1\b0  (
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSArray's\cf2  \cf7 arrayWithObject\cf2 :\cf6 tz\cf2 )'s \cf7 |firstObject|\cf2 ()\
		
\f0\b if
\f1\b0  (\cf6 tz's\cf2  \cf7 isKindOfClass\cf2 :(
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSString\cf2 )) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
			\cf5 -- make a time zone from string if possible\cf2 \
			
\f0\b if
\f1\b0  (
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSTimeZone's\cf2  \cf7 knownTimeZoneNames\cf2 ()'s \cf7 containsObject\cf2 :\cf6 tz\cf2 ) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
				
\f0\b set
\f1\b0  \cf6 tz\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSTimeZone's\cf2  \cf7 timeZoneWithName\cf2 :\cf6 tz\cf2 \
				\cf6 theEvent's\cf2  \cf7 setTimeZone\cf2 :\cf6 tz\cf2 \
			
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
		
\f0\b else
\f1\b0  \cf5 -- assume it's already a time zone\cf2 \
			\cf6 theEvent's\cf2  \cf7 setTimeZone\cf2 :\cf6 tz\cf2 \
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theEvent\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 modify zone
\f1\b0 \cf2 \
\
\cf5 -- You pass the frequency as an integer or string, and the interval as an integer. If you supply a date (AS date or NSDate) for orEndDate:, it will be used, otherwise pass missing value for it, and the repeatCount: integer will be used.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 modify recurrence
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2  \cf4 event frequency\cf2  \cf6 theFreq\cf2  \cf4 event interval\cf2  \cf6 interv\cf2  \cf4 repeats for\cf2  \cf6 repeatCt\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2  \cf4 repeats until\cf2  \cf6 endingDate\cf2  : 
\f2\i \cf4 missing value
\f1\i0 \cf2 \
	
\f0\b if
\f1\b0  \cf6 theFreq\cf2  = 
\f2\i \cf3 do daily
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theFreq\cf2  
\f0\b to
\f1\b0  0\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 theFreq\cf2  = 
\f2\i \cf3 do weekly
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theFreq\cf2  
\f0\b to
\f1\b0  1\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 theFreq\cf2  = 
\f2\i \cf3 do monthly
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theFreq\cf2  
\f0\b to
\f1\b0  2\
	
\f0\b else
\f1\b0  
\f0\b if
\f1\b0  \cf6 theFreq\cf2  = 
\f2\i \cf3 do yearly
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theFreq\cf2  
\f0\b to
\f1\b0  3\
	
\f0\b else
\f1\b0 \
		
\f0\b error
\f1\b0  "Invalid frequency parameter"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b if
\f1\b0  \cf6 endingDate\cf2  
\f0\b is
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 recurrEnd\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKRecurrenceEnd's\cf2  \cf7 recurrenceEndWithOccurrenceCount\cf2 :\cf6 repeatCt\cf2 \
	
\f0\b else
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 recurrEnd\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKRecurrenceEnd's\cf2  \cf7 recurrenceEndWithEndDate\cf2 :\cf6 endingDate\cf2 \
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b set
\f1\b0  \cf6 recurrRule\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 EKRecurrenceRule's\cf2  \cf7 alloc\cf2 ()'s \cf7 initRecurrenceWithFrequency\cf2 :\cf6 theFreq\cf2  \cf7 interval\cf2 :\cf6 interv\cf2  \cf7 |end|\cf2 :\cf6 recurrEnd\cf2 \
	\cf5 -- delete any existing first\cf2 \
	
\f0\b \cf4 stop recurrence
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	\cf6 theEvent's\cf2  \cf7 addRecurrenceRule\cf2 :\cf6 recurrRule\cf2 \
	
\f0\b return
\f1\b0  \cf6 theEvent\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 modify recurrence
\f1\b0 \cf2 \
\
\cf5 -- Turns off recurrence for event.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 stop recurrence
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	
\f0\b if
\f1\b0  \cf6 theEvent's\cf2  \cf7 hasRecurrenceRules\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theRules\cf2  
\f0\b to
\f1\b0  \cf6 theEvent's\cf2  \cf7 |recurrenceRules|\cf2 ()\
		
\f0\b if
\f1\b0  (
\f0\b \cf4 count
\f1\b0 \cf2  
\f0\b of
\f1\b0  \cf6 theRules\cf2 ) > 0 
\f0\b then
\f1\b0  \cf6 theEvent's\cf2  \cf7 removeRecurrenceRule\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  1 
\f0\b of
\f1\b0  \cf6 theRules\cf2 )\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theEvent\cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 stop recurrence
\f1\b0 \cf2 \
\
\cf5 -- After you create or modify an event, you need to save it. For recurring events, futureFlag should be true to make changes apply to future events.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 store event
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2  \cf4 event store\cf2  \cf6 theStore\cf2  \cf4 future events\cf2  \cf6 futureFlag\cf2  : 
\f2\i \cf3 true
\f1\i0 \cf2 \
	
\f0\b set
\f1\b0  \{\cf6 theResult\cf2 , \cf6 theError\cf2 \} 
\f0\b to
\f1\b0  \cf6 theStore's\cf2  \cf7 saveEvent\cf2 :\cf6 theEvent\cf2  \cf7 span\cf2 :\cf6 futureFlag\cf2  \cf7 commit\cf2 :
\f2\i \cf3 true
\f1\i0 \cf2  \cf7 |error|\cf2 :(
\f2\i \cf4 reference
\f1\i0 \cf2 )\
	
\f0\b if
\f1\b0  
\f0\b not
\f1\b0  \cf6 theResult\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0  
\f0\b error
\f1\b0  (\cf6 theError's\cf2  \cf7 |localizedDescription|\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 text
\f1\i0 \cf2 )\

\f0\b end
\f1\b0  
\f0\b \cf4 store event
\f1\b0 \cf2 \
\
\cf5 -- This is the external id used by Calendar.app.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 event identifier for
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	
\f0\b return
\f1\b0  \cf6 theEvent's\cf2  \cf7 |calendarItemExternalIdentifier|\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 text
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 event identifier for
\f1\b0 \cf2 \
\
\cf5 -- returns record.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 event info for
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	\cf5 -- work around problem with null values in dictionaries; set initial nulls for all values that might be missing value\cf2 \
	
\f0\b set
\f1\b0  \cf6 theNull\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSNull's\cf2  \cf7 |null|\cf2 ()\
	
\f0\b set
\f1\b0  \cf6 theDict\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSMutableDictionary's\cf2  \cf7 dictionaryWithObjects\cf2 :\{\cf6 theNull\cf2 , \cf6 theNull\cf2 , \cf6 theNull\cf2 , \cf6 theNull\cf2 , \cf6 theNull\cf2 , \cf6 theNull\cf2 , \cf6 theNull\cf2 \} \cf7 forKeys\cf2 :\{"event_summary", "event_time_zone", "event_location", "event_url", "event_description", "event_organizer", "event_original_date"\}\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 calendar\cf2 ()'s \cf7 title\cf2 ()) \cf7 forKey\cf2 :"calendar_name"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 calendar\cf2 ()'s \cf7 |type|\cf2 ()) 
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theResult\cf2  + 1) 
\f0\b of
\f1\b0  \{"local", "cloud", "Exchange", "subscription", "birthday"\}) \cf7 forKey\cf2 :"calendar_type"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 title\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 theResult\cf2  \cf7 forKey\cf2 :"event_summary"\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |calendarItemExternalIdentifier|\cf2 ()) \cf7 forKey\cf2 :"event_external_ID"\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |startDate|\cf2 ()) \cf7 forKey\cf2 :"event_start_date"\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |endDate|\cf2 ()) \cf7 forKey\cf2 :"event_end_date"\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |isAllDay|\cf2 ()) \cf7 forKey\cf2 :"all_day"\
	
\f0\b set
\f1\b0  \cf6 tz\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 timeZone\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 tz\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 tz's\cf2  \cf7 |name|\cf2 ()) \cf7 forKey\cf2 :"event_time_zone"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 location\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 theResult\cf2  \cf7 forKey\cf2 :"event_location"\
	
\f0\b set
\f1\b0  \cf6 theURL\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 |URL|\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theURL\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theURL's\cf2  \cf7 |absoluteString|\cf2 ()) \cf7 forKey\cf2 :"event_url"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 |hasNotes|\cf2 ()) 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2 \
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 notes\cf2 ())\
		
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 theResult\cf2  \cf7 forKey\cf2 :"event_description"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b set
\f1\b0  \cf6 theAttendees\cf2  
\f0\b to
\f1\b0  \cf6 theEvent's\cf2  \cf7 |hasAttendees|\cf2 ()\
	
\f0\b if
\f1\b0  \cf6 theAttendees\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 attendees\cf2 ()'s \cf7 valueForKey\cf2 :"name") \cf7 forKey\cf2 :"event_attendees"\
	
\f0\b else
\f1\b0 \
		\cf6 theDict's\cf2  \cf7 setObject\cf2 :\{\} \cf7 forKey\cf2 :"event_attendees"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |hasRecurrenceRules|\cf2 ()) \cf7 forKey\cf2 :"event_is_recurring"\
	\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEvent's\cf2  \cf7 |creationDate|\cf2 ()) \cf7 forKey\cf2 :"event_creation_date"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 organizer\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theResult's\cf2  \cf7 |name|\cf2 ())\
		
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 theResult\cf2  \cf7 forKey\cf2 :"event_organizer"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 |occurrenceDate|\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 theResult\cf2  \cf7 forKey\cf2 :"event_original_date"\
	
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  (\cf6 theEvent's\cf2  \cf7 status\cf2 ())\
	
\f0\b if
\f1\b0  \cf6 theResult\cf2  
\f0\b is
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		\cf6 theDict's\cf2  \cf7 setObject\cf2 :"none" \cf7 forKey\cf2 :"event_status"\
	
\f0\b else
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theResult\cf2  
\f0\b to
\f1\b0  \cf6 theResult\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
		\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theResult\cf2  + 1) 
\f0\b of
\f1\b0  \{"none", "confirmed", "tentative", "canceled"\}) \cf7 forKey\cf2 :"event_status"\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  \cf6 theDict\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 record
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 event info for
\f1\b0 \cf2 \
\
\cf5 -- returns a list of records\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 event attendees for
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	
\f0\b if
\f1\b0  \cf6 theEvent's\cf2  \cf7 hasAttendees\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theNull\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSNull's\cf2  \cf7 |null|\cf2 ()\
		
\f0\b set
\f1\b0  \cf6 theAttendees\cf2  
\f0\b to
\f1\b0  \cf6 theEvent's\cf2  \cf7 attendees\cf2 ()\
		
\f0\b set
\f1\b0  \cf6 theArray\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSMutableArray's\cf2  \cf7 array\cf2 ()\
		
\f0\b repeat
\f1\b0  
\f0\b with
\f1\b0  \cf6 anAttendee\cf2  
\f0\b in
\f1\b0  \cf6 theAttendees\cf2 \
			
\f0\b set
\f1\b0  \cf6 theDict\cf2  
\f0\b to
\f1\b0  (
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSMutableDictionary's\cf2  \cf7 dictionaryWithObjects\cf2 :\{\cf6 theNull\cf2 \} \cf7 forKeys\cf2 :\{"attendee_email"\})\
			(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 anAttendee's\cf2  \cf7 |name|\cf2 ()) \cf7 forKey\cf2 :"attendee_name")\
			
\f0\b set
\f1\b0  \cf6 theEmail\cf2  
\f0\b to
\f1\b0  \cf6 anAttendee's\cf2  \cf7 |URL|\cf2 ()\
			
\f0\b if
\f1\b0  \cf6 theEmail\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  (\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theEmail's\cf2  \cf7 |resourceSpecifier|\cf2 ()) \cf7 forKey\cf2 :"attendee_email")\
			
\f0\b set
\f1\b0  \cf6 theStatus\cf2  
\f0\b to
\f1\b0  \cf6 anAttendee's\cf2  \cf7 |participantStatus|\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
			(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theStatus\cf2  + 1) 
\f0\b of
\f1\b0  \{"unknown", "pending", "accepted", "declined", "tentative", "delegated", "completed", "in process"\}) \cf7 forKey\cf2 :"attendee_status")\
			
\f0\b set
\f1\b0  \cf6 theType\cf2  
\f0\b to
\f1\b0  \cf6 anAttendee's\cf2  \cf7 |participantType|\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
			(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theType\cf2  + 1) 
\f0\b of
\f1\b0  \{"unknown", "person", "room", "resource", "group"\}) \cf7 forKey\cf2 :"attendee_type")\
			
\f0\b set
\f1\b0  \cf6 theRole\cf2  
\f0\b to
\f1\b0  \cf6 anAttendee's\cf2  \cf7 |participantRole|\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
			(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theRole\cf2  + 1) 
\f0\b of
\f1\b0  \{"unknown", "required", "optional", "chair", "nonparticipant"\}) \cf7 forKey\cf2 :"attendee_role")\
			(\cf6 theArray's\cf2  \cf7 addObject\cf2 :(\cf6 theDict's\cf2  \cf7 |copy|\cf2 ()))\
		
\f0\b end
\f1\b0  
\f0\b repeat
\f1\b0 \
		
\f0\b return
\f1\b0  \cf6 theArray\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 list
\f1\i0 \cf2 \
	
\f0\b else
\f1\b0 \
		
\f0\b return
\f1\b0  \{\}\
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \

\f0\b end
\f1\b0  
\f0\b \cf4 event attendees for
\f1\b0 \cf2 \
\
\cf5 -- Returns a record. If occurrence_end_date is missing value, occurrence_frequency is used.\cf2 \

\f0\b on
\f1\b0  
\f0\b \cf4 event recurrence for
\f1\b0 \cf2  \cf4 event\cf2  \cf6 theEvent\cf2 \
	
\f0\b if
\f1\b0  \cf6 theEvent's\cf2  \cf7 hasRecurrenceRules\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 boolean
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
		
\f0\b set
\f1\b0  \cf6 theNull\cf2  
\f0\b to
\f1\b0  
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSNull's\cf2  \cf7 |null|\cf2 ()\
		
\f0\b set
\f1\b0  \cf6 theDict\cf2  
\f0\b to
\f1\b0  (
\f2\i \cf3 current application's
\f1\i0 \cf2  \cf6 NSMutableDictionary's\cf2  \cf7 dictionaryWithObjects\cf2 :\{\cf6 theNull\cf2 \} \cf7 forKeys\cf2 :\{"occurrence_end_date"\})\
		
\f0\b set
\f1\b0  \cf6 theRule\cf2  
\f0\b to
\f1\b0  \cf6 theEvent's\cf2  \cf7 |recurrenceRules|\cf2 ()'s \cf7 firstObject\cf2 ()\
		
\f0\b set
\f1\b0  \cf6 theFreq\cf2  
\f0\b to
\f1\b0  \cf6 theRule's\cf2  \cf7 frequency\cf2 () 
\f0\b as
\f1\b0  
\f2\i \cf4 integer
\f1\i0 \cf2 \
		(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(
\f2\i \cf4 item
\f1\i0 \cf2  (\cf6 theFreq\cf2  + 1) 
\f0\b of
\f1\b0  \{"daily", "weekly", "monthly", "yearly"\}) \cf7 forKey\cf2 :"occurrence_frequency")\
		(\cf6 theDict's\cf2  \cf7 setObject\cf2 :(\cf6 theRule's\cf2  \cf7 interval\cf2 ()) \cf7 forKey\cf2 :"occurrence_interval")\
		
\f0\b set
\f1\b0  \cf6 recurrEnd\cf2  
\f0\b to
\f1\b0  \cf6 theRule's\cf2  \cf7 |recurrenceEnd|\cf2 ()\
		
\f0\b if
\f1\b0  \cf6 recurrEnd\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0 \
			
\f0\b set
\f1\b0  \cf6 recurrEndDate\cf2  
\f0\b to
\f1\b0  \cf6 recurrEnd's\cf2  \cf7 |endDate|\cf2 ()\
			
\f0\b if
\f1\b0  \cf6 recurrEndDate\cf2  
\f0\b is
\f1\b0  
\f0\b not
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2  
\f0\b then
\f1\b0  \cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 recurrEndDate\cf2  \cf7 forKey\cf2 :"occurrence_end_date"\
			
\f0\b set
\f1\b0  \cf6 recurrCount\cf2  
\f0\b to
\f1\b0  \cf6 recurrEnd's\cf2  \cf7 |occurrenceCount|\cf2 ()\
			\cf6 theDict's\cf2  \cf7 setObject\cf2 :\cf6 recurrCount\cf2  \cf7 forKey\cf2 :"occurrence_count"\
		
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
		
\f0\b return
\f1\b0  \cf6 theDict\cf2  
\f0\b as
\f1\b0  
\f2\i \cf4 record
\f1\i0 \cf2 \
	
\f0\b end
\f1\b0  
\f0\b if
\f1\b0 \
	
\f0\b return
\f1\b0  
\f2\i \cf4 missing value
\f1\i0 \cf2 \

\f0\b end
\f1\b0  
\f0\b \cf4 event recurrence for
\f1\b0 \cf2 \
}